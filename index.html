<!DOCTYPE html>
<html lang="da">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Morgendis - En bedre vejrudsigt</title>
    <meta name="description" content="Morgendis tilbyder gratis vejrudsigt med detaljerede prognoser, radaranimation, temperatur, nedb√∏r, vind og mange flere variabler. Flere prognosemodeller inkl. DMI, ECMWF og GFS.">
    <meta name="keywords" content="vejrudsigt, vejr Danmark, dansk vejr, vejrprognose, radar Danmark, temperatur, nedb√∏r, vind, DMI, ECMWF, GFS, vejrkort, morgendis">
    <meta name="author" content="Bjarke Bolding">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://morgendis.dk/">

    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Morgendis - En bedre vejrudsigt">
    <meta property="og:description" content="Detaljeret dansk vejrudsigt med radar, temperatur, nedb√∏r og vind.">
    <meta property="og:url" content="https://morgendis.dk/">
    <meta property="og:site_name" content="Morgendis">
    <meta property="og:locale" content="da_DK">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Morgendis - En bedre vejrudsigt">
    <meta name="twitter:description" content="Detaljeret dansk vejrudsigt med radar, temperatur, nedb√∏r og vind.">

    <!-- Structured Data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "Morgendis",
        "url": "https://morgendis.dk",
        "description": "Gratis dansk vejrudsigt med detaljerede prognoser, radaranimation.",
        "applicationCategory": "WeatherApplication",
        "operatingSystem": "Web",
        "author": {
            "@type": "Person",
            "name": "Bjarke Bolding"
        },
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "DKK"
        },
        "inLanguage": "da"
    }
    </script>

    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üå´Ô∏è</text></svg>">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
/* ============================================
   CSS VARIABLES & TIME-BASED THEMES
   ============================================ */
:root {
    --bg-primary: #1a1a2e;
    --bg-secondary: #16213e;
    --bg-card: rgba(255, 255, 255, 0.08);
    --bg-control: rgba(0, 0, 0, 0.4);
    --accent: #6eb5ff;
    --accent-secondary: #a78bfa;
    --text-primary: #ffffff;
    --text-secondary: #94a3b8;
    --text-muted: #cbd5e1;
    --border: rgba(255, 255, 255, 0.12);
    --shadow: rgba(0, 0, 0, 0.4);
    --glass: rgba(255, 255, 255, 0.05);
    --bg-overlay: linear-gradient(135deg, rgba(26, 26, 46, 0.85) 0%, rgba(22, 33, 62, 0.9) 100%);
    --grid-size: 20px;
}

[data-time-theme="night"] {
    --bg-primary: #0a0a14;
    --bg-secondary: #0f0f1a;
    --bg-card: rgba(255, 255, 255, 0.04);
    --bg-control: rgba(0, 0, 0, 0.6);
    --accent: #7c9ed9;
    --accent-secondary: #9f7aea;
    --text-primary: #e2e8f0;
    --text-secondary: #64748b;
    --text-muted: #94a3b8;
    --border: rgba(255, 255, 255, 0.08);
    --bg-overlay: linear-gradient(135deg, rgba(10, 10, 20, 0.92) 0%, rgba(15, 15, 26, 0.95) 100%);
}

[data-time-theme="dawn"] {
    --bg-primary: #2d1b4e;
    --bg-secondary: #4a2c6a;
    --bg-card: rgba(255, 255, 255, 0.08);
    --bg-control: rgba(0, 0, 0, 0.4);
    --accent: #f0a8d0;
    --accent-secondary: #ffc078;
    --text-primary: #fdf4ff;
    --text-secondary: #d8b4fe;
    --text-muted: #e9d5ff;
    --border: rgba(255, 255, 255, 0.15);
    --bg-overlay: linear-gradient(135deg, rgba(45, 27, 78, 0.8) 0%, rgba(74, 44, 106, 0.85) 100%);
}

[data-time-theme="morning"] {
    --bg-primary: #f0f7ff;
    --bg-secondary: #e0efff;
    --bg-card: rgba(255, 255, 255, 0.6);
    --bg-control: rgba(255, 255, 255, 0.8);
    --accent: #3b82f6;
    --accent-secondary: #8b5cf6;
    --text-primary: #1e3a5f;
    --text-secondary: #475569;
    --text-muted: #334155;
    --border: rgba(0, 0, 0, 0.1);
    --shadow: rgba(0, 0, 0, 0.1);
    --bg-overlay: linear-gradient(135deg, rgba(240, 247, 255, 0.7) 0%, rgba(224, 239, 255, 0.75) 100%);
}

[data-time-theme="afternoon"] {
    --bg-primary: #fefce8;
    --bg-secondary: #fef3c7;
    --bg-card: rgba(255, 255, 255, 0.7);
    --bg-control: rgba(255, 255, 255, 0.85);
    --accent: #f59e0b;
    --accent-secondary: #ef4444;
    --text-primary: #422006;
    --text-secondary: #78350f;
    --text-muted: #451a03;
    --border: rgba(0, 0, 0, 0.12);
    --shadow: rgba(0, 0, 0, 0.15);
    --bg-overlay: linear-gradient(135deg, rgba(254, 252, 232, 0.65) 0%, rgba(254, 243, 199, 0.7) 100%);
}

[data-time-theme="evening"] {
    --bg-primary: #1e1b4b;
    --bg-secondary: #312e81;
    --bg-card: rgba(255, 255, 255, 0.06);
    --bg-control: rgba(0, 0, 0, 0.45);
    --accent: #f97316;
    --accent-secondary: #ec4899;
    --text-primary: #fef3c7;
    --text-secondary: #c4b5fd;
    --text-muted: #ddd6fe;
    --border: rgba(255, 255, 255, 0.1);
    --bg-overlay: linear-gradient(135deg, rgba(30, 27, 75, 0.85) 0%, rgba(49, 46, 129, 0.88) 100%);
}

/* ============================================
   BASE STYLES
   ============================================ */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    min-height: 100vh;
    color: var(--text-primary);
    overflow-x: hidden;
}

.background-layer {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: -2;
    transition: background 1.5s ease-in-out;
}

.background-layer::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background:
        radial-gradient(ellipse 120% 60% at 20% 80%, rgba(255,255,255,0.15) 0%, transparent 50%),
        radial-gradient(ellipse 100% 50% at 80% 70%, rgba(255,255,255,0.1) 0%, transparent 40%),
        radial-gradient(ellipse 80% 40% at 50% 90%, rgba(255,255,255,0.12) 0%, transparent 45%);
    pointer-events: none;
    animation: mistFloat 20s ease-in-out infinite;
}

@keyframes mistFloat {
    0%, 100% { opacity: 0.7; transform: translateY(0); }
    50% { opacity: 1; transform: translateY(-10px); }
}

.background-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: -1;
    background: var(--bg-overlay);
}

/* ============================================
   HEADER
   ============================================ */
.header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 16px;
    background: var(--bg-control);
    backdrop-filter: blur(20px);
    border-bottom: 1px solid var(--border);
    flex-wrap: wrap;
    gap: 8px;
    position: sticky;
    top: 0;
    z-index: 1000;
}

.header-brand {
    display: flex;
    align-items: center;
    gap: 12px;
}

.header-brand h1 {
    font-size: 1.3rem;
    font-weight: 700;
    background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.time-greeting {
    display: flex;
    flex-direction: column;
    font-size: 0.65rem;
    color: var(--text-secondary);
    border-left: 1px solid var(--border);
    padding-left: 10px;
}

.time-greeting .time {
    font-size: 0.85rem;
    font-weight: 600;
    color: var(--text-primary);
}

.time-greeting .message {
    font-size: 0.6rem;
    color: var(--accent);
}

.header-controls {
    display: flex;
    align-items: center;
    gap: 10px;
    flex-wrap: wrap;
}

/* ============================================
   FORM CONTROLS
   ============================================ */
.control-group {
    display: flex;
    align-items: center;
    gap: 5px;
}

.control-group label {
    font-size: 0.7rem;
    color: var(--text-secondary);
    white-space: nowrap;
}

select, input[type="text"], input[type="number"] {
    background: var(--bg-card);
    border: 1px solid var(--border);
    color: var(--text-primary);
    padding: 4px 8px;
    border-radius: 5px;
    font-size: 0.75rem;
    cursor: pointer;
}

select:focus, input:focus {
    outline: none;
    border-color: var(--accent);
}

input[type="number"] { width: 50px; }

.city-search-wrapper { position: relative; }
#city-search { width: 140px; }
#city-search::placeholder { color: var(--text-secondary); }

.search-results {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    margin-top: 4px;
    background: var(--bg-primary);
    border: 1px solid var(--border);
    border-radius: 5px;
    max-height: 200px;
    overflow-y: auto;
    z-index: 2000;
    display: none;
    box-shadow: 0 4px 12px var(--shadow);
}

.search-results.active { display: block; }

.search-result-item {
    padding: 6px 8px;
    cursor: pointer;
    font-size: 0.75rem;
    border-bottom: 1px solid var(--border);
}

.search-result-item:last-child { border-bottom: none; }
.search-result-item:hover { background: var(--glass); }
.search-result-item small {
    color: var(--text-secondary);
    display: block;
    font-size: 0.65rem;
}

/* ============================================
   BUTTONS
   ============================================ */
.btn {
    background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
    border: none;
    color: white;
    padding: 4px 10px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 0.7rem;
    font-weight: 500;
    transition: transform 0.2s;
}

.btn:hover {
    transform: translateY(-1px);
}

.btn-icon {
    background: transparent;
    border: none;
    color: var(--text-secondary);
    padding: 2px 5px;
    cursor: pointer;
    font-size: 0.85rem;
    transition: color 0.2s;
    line-height: 1;
}

.btn-icon:hover { color: var(--accent); }
.btn-icon.danger:hover { color: #ef4444; }
.mobile-only { display: none; }

.days-toggle { gap: 0 !important; }
.days-btn {
    border-radius: 0;
    background: var(--bg-control);
    border: 1px solid var(--border);
    color: var(--text-secondary);
    opacity: 0.8;
}
.days-btn:hover { color: var(--text-primary); opacity: 1; }
.days-btn:first-child { border-radius: 5px 0 0 5px; }
.days-btn:last-child { border-radius: 0 5px 5px 0; border-left: none; }
.days-btn.active {
    opacity: 1;
    color: white;
    background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
    border-color: var(--accent);
}

/* ============================================
   WORKSPACE - DRAGGABLE PANELS
   ============================================ */
#workspace {
    position: relative;
    min-height: calc(100vh - 50px);
    padding: 10px;
}

.panel {
    position: absolute;
    background: var(--bg-card);
    border-radius: 8px;
    backdrop-filter: blur(20px);
    border: 1px solid var(--border);
    overflow: hidden;
    display: flex;
    flex-direction: column;
    min-width: 280px;
    box-shadow: 0 2px 10px var(--shadow);
    transition: left 0.25s ease, top 0.25s ease, box-shadow 0.2s;
}

.panel:hover {
    box-shadow: 0 4px 20px var(--shadow);
}

.panel.dragging {
    opacity: 0.9;
    z-index: 999 !important;
    cursor: grabbing;
    box-shadow: 0 8px 30px var(--shadow);
    transition: box-shadow 0.2s;
}

.panel.minimized .panel-content,
.panel.minimized .resize-handle {
    display: none;
}

.panel.minimized {
    min-height: auto;
    height: auto !important;
    opacity: 0.85;
    transition: opacity 0.15s;
}
.panel.minimized:hover {
    opacity: 1;
}
.panel.minimized .panel-header {
    border-bottom: none;
    border-radius: 8px;
}
.minimized-vars {
    font-size: 0.7rem;
    opacity: 0.8;
    margin-left: 6px;
}

@media (max-width: 768px) {
    .header { padding: 6px 10px; }
    .header-brand h1 { font-size: 1rem; }
    .header-controls { gap: 6px; }
    .control-group label { font-size: 0.6rem; }
    select, input[type="text"], input[type="number"] { font-size: 0.65rem; padding: 3px 5px; }
    #city-search { width: 100px; }

    #workspace {
        padding: 5px;
    }
    .panel {
        position: static !important;
        width: 100% !important;
        height: auto !important;
        left: auto !important;
        top: auto !important;
        margin-bottom: 8px;
    }
    .panel-map {
        height: 400px !important;
    }
    .panel-header {
        cursor: default;
    }
    .mobile-only {
        display: flex !important;
    }
    .resize-handle {
        display: none;
    }

    /* Compact chart labels on mobile */
    .chart-section .y-label,
    .chart-section .y-label-right {
        width: 10px;
        font-size: 0.4rem;
    }
    .day-headers,
    .weather-icons-row,
    .wind-arrows-row,
    .hour-labels {
        padding-left: 30px;
        padding-right: 30px;
    }
    .weather-icon-cell { font-size: 0.7rem; }
    .day-header { font-size: 0.6rem; padding: 3px 4px; }
    .hour-label { font-size: 0.45rem; }
    .wind-arrow-cell { font-size: 0.6rem; }

    /* Larger touch targets on mobile */
    .btn-icon { padding: 6px 8px; font-size: 1rem; min-width: 32px; min-height: 32px; display: flex; align-items: center; justify-content: center; }
    .panel-buttons { gap: 0; }

}

.panel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 6px 10px;
    background: var(--bg-control);
    border-bottom: 1px solid var(--border);
    user-select: none;
    gap: 8px;
    cursor: grab;
}

.panel-header h3 {
    font-size: 0.8rem;
    color: var(--accent);
    display: flex;
    align-items: center;
    gap: 6px;
    flex: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.panel-header .coords {
    font-size: 0.55rem;
    color: var(--text-secondary);
    font-weight: normal;
}

.panel-buttons {
    display: flex;
    gap: 2px;
}

.panel-content {
    overflow: auto;
    display: flex;
    flex-direction: column;
}

.panel-map .panel-content {
    flex: 1;
    min-height: 200px;
}

.resize-handle {
    position: absolute;
    bottom: 0;
    right: 0;
    width: 16px;
    height: 16px;
    cursor: nwse-resize;
    opacity: 0.4;
    z-index: 10;
}

.resize-handle::after {
    content: '';
    position: absolute;
    bottom: 3px;
    right: 3px;
    width: 8px;
    height: 8px;
    border-right: 2px solid var(--accent);
    border-bottom: 2px solid var(--accent);
}

.resize-handle:hover { opacity: 0.8; }

/* City panels: width-only resize handle on right edge */
.panel:not(.panel-map) .resize-handle {
    cursor: ew-resize;
    width: 8px;
    height: 100%;
    top: 0;
    bottom: auto;
}

.panel:not(.panel-map) .resize-handle::after {
    bottom: auto;
    top: 50%;
    right: 1px;
    width: 3px;
    height: 20px;
    transform: translateY(-50%);
    border: none;
    border-right: 2px solid var(--accent);
}

/* ============================================
   MAP PANEL
   ============================================ */
#map {
    flex: 1;
    min-height: 200px;
}

.map-controls {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 6px 10px;
    background: var(--bg-control);
    border-top: 1px solid var(--border);
}

.radar-controls {
    display: flex;
    align-items: center;
    gap: 6px;
}

#timestamp {
    font-size: 0.65rem;
    color: var(--text-secondary);
    min-width: 80px;
    text-align: center;
}

#frame-slider {
    width: 70px;
    accent-color: var(--accent);
}

.layer-toggles {
    display: flex;
    gap: 8px;
    align-items: center;
}

.layer-toggles label {
    display: flex;
    align-items: center;
    gap: 3px;
    font-size: 0.65rem;
    color: var(--text-muted);
    cursor: pointer;
}

.layer-toggles input[type="checkbox"] {
    accent-color: var(--accent);
    width: 11px;
    height: 11px;
}

/* City markers on map */
.city-marker-label {
    background: rgba(0, 0, 0, 0.65);
    border: 1px solid rgba(255, 255, 255, 0.15);
    border-radius: 6px;
    padding: 3px 7px;
    backdrop-filter: blur(8px);
    white-space: nowrap;
    display: flex;
    align-items: center;
    gap: 5px;
    width: fit-content;
    pointer-events: auto;
    transition: background 0.2s;
}
.city-marker-label:hover {
    background: rgba(0, 0, 0, 0.8);
}

.city-marker-label .name {
    font-weight: 600;
    font-size: 0.65rem;
    color: #e2e8f0;
    letter-spacing: 0.02em;
}

.city-marker-label .weather-icon {
    font-size: 0.75rem;
    line-height: 1;
}

.city-marker-label .temp {
    font-size: 0.7rem;
    font-weight: 700;
    color: #6eb5ff;
}

.city-marker-label .wind {
    font-size: 0.55rem;
    color: #94a3b8;
    opacity: 0.9;
}

.city-marker-label .sep {
    width: 1px;
    height: 12px;
    background: rgba(255, 255, 255, 0.15);
    flex-shrink: 0;
}

.leaflet-div-icon {
    background: none !important;
    border: none !important;
    overflow: visible !important;
    transform: translate(-50%, -50%);
}

/* ============================================
   CITY CARD
   ============================================ */
.current-weather {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px;
    border-bottom: 1px solid var(--border);
}

.weather-icon {
    font-size: 2rem;
    line-height: 1;
}

.temp-display { text-align: center; }

.temp-value {
    font-size: 1.8rem;
    font-weight: 300;
    line-height: 1;
}

.feels-like {
    font-size: 0.6rem;
    color: var(--text-secondary);
}

.weather-details {
    flex: 1;
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 1px 10px;
    font-size: 0.65rem;
}

.detail-item {
    display: flex;
    justify-content: space-evenly;
}

.detail-label { color: var(--text-secondary); }
.detail-value { font-weight: 500; }

/* Variable selector */
.variable-selector {
    padding: 6px 10px;
    background: var(--bg-control);
    border-bottom: 1px solid var(--border);
}

.variable-selector summary {
    font-size: 0.65rem;
    color: var(--text-secondary);
    cursor: pointer;
}

.variable-selector summary:hover { color: var(--accent); }

.variable-groups {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
    gap: 8px;
    margin-top: 8px;
    max-height: 250px;
    overflow-y: auto;
}

.variable-group {
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: 5px;
    padding: 6px;
}

.variable-group h4 {
    font-size: 0.6rem;
    color: var(--accent);
    margin-bottom: 4px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.variable-group label {
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 0.58rem;
    color: var(--text-muted);
    cursor: pointer;
    padding: 1px 0;
}

.variable-group label:hover { color: var(--text-primary); }

.variable-group input[type="checkbox"] {
    accent-color: var(--accent);
    width: 10px;
    height: 10px;
}

/* ============================================
   DETAILED FORECAST
   ============================================ */
.forecast-container {
    flex: 1;
    overflow-x: auto;
    overflow-y: auto;
}

.forecast-wrapper {
    min-width: 300px;
    padding: 10px 6px;
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.day-headers {
    display: flex;
    border-bottom: 1px solid var(--border);
    margin-bottom: 6px;
    /* Align with chart plot area: 14px y-label + 30px y-axis on each side */
    padding-left: 44px;
    padding-right: 44px;
}

.day-header {
    flex: 1;
    text-align: left;
    padding: 4px 8px;
    font-size: 0.7rem;
    font-weight: 600;
    color: var(--text-primary);
    border-left: 1px solid var(--border);
}

.day-header:first-child { border-left: none; }
.day-header.today { color: var(--accent); }

.weather-icons-row {
    display: flex;
    padding: 2px 0;
    margin-bottom: 4px;
    padding-left: 44px;
    padding-right: 44px;
}

.weather-icon-cell {
    flex: 1;
    text-align: center;
    font-size: 0.9rem;
}

.chart-section {
    position: relative;
    margin-bottom: 8px;
    display: flex;
    align-items: center;
}

.chart-section .y-label {
    flex-shrink: 0;
    width: 14px;
    font-size: 0.5rem;
    color: var(--text-secondary);
    white-space: nowrap;
    text-align: center;
    writing-mode: vertical-rl;
    transform: rotate(180deg);
}

.chart-section .y-label-right {
    flex-shrink: 0;
    width: 14px;
    font-size: 0.5rem;
    color: var(--accent);
    white-space: nowrap;
    text-align: center;
    writing-mode: vertical-rl;
}

.chart-canvas-wrapper {
    flex: 1;
    min-width: 0;
    position: relative;
}

.chart-canvas-wrapper canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100% !important;
    height: 100% !important;
}

.chart-container-temp .chart-canvas-wrapper { height: 100px; }
.chart-container-precip .chart-canvas-wrapper { height: 60px; }
.chart-container-wind .chart-canvas-wrapper { height: 80px; }
.chart-container-pressure .chart-canvas-wrapper { height: 60px; }
.chart-container-humidity .chart-canvas-wrapper { height: 60px; }
.chart-container-clouds .chart-canvas-wrapper { height: 60px; }
.chart-container-solar .chart-canvas-wrapper { height: 60px; }

.wind-arrows-row {
    display: flex;
    padding: 2px 0;
    padding-left: 44px;
    padding-right: 44px;
}

.wind-arrow-cell {
    flex: 1;
    text-align: center;
    font-size: 0.75rem;
    color: var(--text-secondary);
}

.hour-labels {
    display: flex;
    padding-left: 44px;
    padding-right: 44px;
    border-top: 1px solid var(--border);
    padding-top: 2px;
}

.hour-label {
    flex: 1;
    text-align: center;
    font-size: 0.55rem;
    color: var(--text-secondary);
}

/* Loading & Error */
.loading-indicator {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100px;
    color: var(--text-secondary);
    gap: 8px;
    font-size: 0.75rem;
}

.loading-indicator::before {
    content: '';
    width: 16px;
    height: 16px;
    border: 2px solid var(--border);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin { to { transform: rotate(360deg); } }

.error-message {
    text-align: center;
    padding: 15px;
    color: #ef4444;
    font-size: 0.75rem;
}

/* ============================================
   FOOTER
   ============================================ */
.footer {
    text-align: center;
    padding: 8px 16px;
    background: var(--bg-control);
    backdrop-filter: blur(20px);
    border-top: 1px solid var(--border);
    font-size: 0.65rem;
    color: var(--text-secondary);
}

.footer a { color: var(--accent); }

/* ============================================
   UTILITIES
   ============================================ */
.hidden { display: none !important; }

::-webkit-scrollbar { width: 5px; height: 5px; }
::-webkit-scrollbar-track { background: var(--bg-secondary); }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: var(--accent); }
    </style>
</head>
<body data-time-theme="morning">
    <div class="background-layer" id="bg-layer"></div>
    <div class="background-overlay"></div>

    <header class="header">
        <div class="header-brand">
            <h1>Morgendis</h1>
            <div class="time-greeting">
                <span class="time" id="current-time">--:--</span>
                <span class="message" id="greeting-message">Velkommen!</span>
            </div>
        </div>

        <div class="header-controls">
            <div class="control-group days-toggle">
                <button class="btn days-btn active" data-mode="48h">2 dage</button>
                <button class="btn days-btn" data-mode="3-9d">3-9 dage</button>
            </div>

            <div class="control-group city-search-wrapper">
                <label for="city-search">Tilf√∏j:</label>
                <input type="text" id="city-search" placeholder="S√∏g by...">
                <div class="search-results" id="search-results"></div>
            </div>

            <button class="btn" id="add-map-btn" title="Tilf√∏j radarkort">+ Kort</button>
            <button class="btn-icon" id="reset-btn" title="Nulstil">‚Üª</button>
        </div>
    </header>

    <div id="workspace"></div>

    <footer class="footer">
        Bjarke Bolding |
        Vejrdata: <a href="https://open-meteo.com/" target="_blank">Open-Meteo</a> |
        Radar: <a href="https://www.rainviewer.com/" target="_blank">RainViewer</a> |
        <span id="last-update"></span>
    </footer>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>

    <script>
'use strict';

// ============================================
// CONFIGURATION - ALL OPEN-METEO VARIABLES
// ============================================
const Config = {
    defaultCities: [
        { id: 'copenhagen', name: 'K√∏benhavn', lat: 55.6761, lon: 12.5683 },
        { id: 'aarhus', name: 'Aarhus', lat: 56.1629, lon: 10.2039 }
    ],

    // Complete Open-Meteo variable groups
    variableGroups: {
        temperature: {
            name: 'Temperatur',
            icon: 'üå°Ô∏è',
            variables: [
                { id: 'temperature_2m', name: 'Temp (2m)', unit: '¬∞C', color: '#1e40af', type: 'line' },
                { id: 'apparent_temperature', name: 'F√∏les som', unit: '¬∞C', color: '#dc2626', type: 'line' },
                { id: 'dew_point_2m', name: 'Dugpunkt', unit: '¬∞C', color: '#14b8a6', type: 'line' },
                { id: 'temperature_80m', name: 'Temp (80m)', unit: '¬∞C', color: '#3b82f6', type: 'line' },
                { id: 'temperature_120m', name: 'Temp (120m)', unit: '¬∞C', color: '#6366f1', type: 'line' },
                { id: 'temperature_180m', name: 'Temp (180m)', unit: '¬∞C', color: '#8b5cf6', type: 'line' }
            ]
        },
        precipitation: {
            name: 'Nedb√∏r',
            icon: 'üåßÔ∏è',
            variables: [
                { id: 'precipitation', name: 'Nedb√∏r total', unit: 'mm', color: '#3b82f6', type: 'bar' },
                { id: 'rain', name: 'Regn', unit: 'mm', color: '#2563eb', type: 'bar' },
                { id: 'showers', name: 'Byger', unit: 'mm', color: '#0ea5e9', type: 'bar' },
                { id: 'snowfall', name: 'Sne', unit: 'cm', color: '#e2e8f0', type: 'bar' },
                { id: 'snow_depth', name: 'Snedybde', unit: 'm', color: '#cbd5e1', type: 'line' },
                { id: 'precipitation_probability', name: 'Sandsynlighed', unit: '%', color: '#06b6d4', type: 'line' },
                { id: 'freezing_level_height', name: 'Fryseniveau', unit: 'm', color: '#67e8f9', type: 'line' }
            ]
        },
        wind: {
            name: 'Vind',
            icon: 'üí®',
            variables: [
                { id: 'wind_speed_10m', name: 'Vind (10m)', unit: 'm/s', color: '#0d9488', type: 'line' },
                { id: 'wind_speed_80m', name: 'Vind (80m)', unit: 'm/s', color: '#14b8a6', type: 'line' },
                { id: 'wind_speed_120m', name: 'Vind (120m)', unit: 'm/s', color: '#2dd4bf', type: 'line' },
                { id: 'wind_speed_180m', name: 'Vind (180m)', unit: 'm/s', color: '#5eead4', type: 'line' },
                { id: 'wind_gusts_10m', name: 'Vindst√∏d', unit: 'm/s', color: '#0d9488', type: 'line', dashed: true },
                { id: 'wind_direction_10m', name: 'Retning (10m)', unit: '¬∞', color: '#6b7280', type: 'arrows' },
                { id: 'wind_direction_80m', name: 'Retning (80m)', unit: '¬∞', color: '#9ca3af', type: 'arrows' },
                { id: 'wind_direction_120m', name: 'Retning (120m)', unit: '¬∞', color: '#d1d5db', type: 'arrows' }
            ]
        },
        pressure: {
            name: 'Lufttryk',
            icon: 'üìä',
            variables: [
                { id: 'surface_pressure', name: 'Overfladetryk', unit: 'hPa', color: '#a855f7', type: 'line' },
                { id: 'pressure_msl', name: 'Havniveau', unit: 'hPa', color: '#c084fc', type: 'line' }
            ]
        },
        humidity: {
            name: 'Fugtighed',
            icon: 'üíß',
            variables: [
                { id: 'relative_humidity_2m', name: 'Rel. fugtighed', unit: '%', color: '#8b5cf6', type: 'line' },
                { id: 'vapour_pressure_deficit', name: 'VPD', unit: 'kPa', color: '#a78bfa', type: 'line' },
                { id: 'evapotranspiration', name: 'Evapotranspiration', unit: 'mm', color: '#c4b5fd', type: 'bar' }
            ]
        },
        clouds: {
            name: 'Skyer',
            icon: '‚òÅÔ∏è',
            variables: [
                { id: 'cloud_cover', name: 'Total skyd√¶kke', unit: '%', color: '#6366f1', type: 'line' },
                { id: 'cloud_cover_low', name: 'Lave skyer', unit: '%', color: '#818cf8', type: 'line' },
                { id: 'cloud_cover_mid', name: 'Mellem skyer', unit: '%', color: '#a5b4fc', type: 'line' },
                { id: 'cloud_cover_high', name: 'H√∏je skyer', unit: '%', color: '#c7d2fe', type: 'line' },
                { id: 'visibility', name: 'Sigtbarhed', unit: 'm', color: '#e0e7ff', type: 'line' }
            ]
        },
        solar: {
            name: 'Sol & Str√•ling',
            icon: '‚òÄÔ∏è',
            variables: [
                { id: 'uv_index', name: 'UV-indeks', unit: '', color: '#f59e0b', type: 'line' },
                { id: 'uv_index_clear_sky', name: 'UV (klar himmel)', unit: '', color: '#fbbf24', type: 'line' },
                { id: 'sunshine_duration', name: 'Solskin', unit: 's', color: '#fcd34d', type: 'bar' },
                { id: 'shortwave_radiation', name: 'Kortb√∏lge', unit: 'W/m¬≤', color: '#fde047', type: 'line' },
                { id: 'direct_radiation', name: 'Direkte', unit: 'W/m¬≤', color: '#facc15', type: 'line' },
                { id: 'diffuse_radiation', name: 'Diffus', unit: 'W/m¬≤', color: '#eab308', type: 'line' },
                { id: 'direct_normal_irradiance', name: 'DNI', unit: 'W/m¬≤', color: '#ca8a04', type: 'line' },
                { id: 'global_tilted_irradiance', name: 'GTI', unit: 'W/m¬≤', color: '#a16207', type: 'line' },
                { id: 'terrestrial_radiation', name: 'Jordstr√•ling', unit: 'W/m¬≤', color: '#854d0e', type: 'line' }
            ]
        },
        soil: {
            name: 'Jord',
            icon: 'üå±',
            variables: [
                { id: 'soil_temperature_0cm', name: 'Jordtemp (0cm)', unit: '¬∞C', color: '#78350f', type: 'line' },
                { id: 'soil_temperature_6cm', name: 'Jordtemp (6cm)', unit: '¬∞C', color: '#92400e', type: 'line' },
                { id: 'soil_temperature_18cm', name: 'Jordtemp (18cm)', unit: '¬∞C', color: '#b45309', type: 'line' },
                { id: 'soil_temperature_54cm', name: 'Jordtemp (54cm)', unit: '¬∞C', color: '#d97706', type: 'line' },
                { id: 'soil_moisture_0_to_1cm', name: 'Jordfugt (0-1cm)', unit: 'm¬≥/m¬≥', color: '#65a30d', type: 'line' },
                { id: 'soil_moisture_1_to_3cm', name: 'Jordfugt (1-3cm)', unit: 'm¬≥/m¬≥', color: '#84cc16', type: 'line' },
                { id: 'soil_moisture_3_to_9cm', name: 'Jordfugt (3-9cm)', unit: 'm¬≥/m¬≥', color: '#a3e635', type: 'line' },
                { id: 'soil_moisture_9_to_27cm', name: 'Jordfugt (9-27cm)', unit: 'm¬≥/m¬≥', color: '#bef264', type: 'line' },
                { id: 'soil_moisture_27_to_81cm', name: 'Jordfugt (27-81cm)', unit: 'm¬≥/m¬≥', color: '#d9f99d', type: 'line' }
            ]
        },
        atmospheric: {
            name: 'Atmosf√¶risk',
            icon: 'üåÄ',
            variables: [
                { id: 'cape', name: 'CAPE', unit: 'J/kg', color: '#dc2626', type: 'line' },
                { id: 'lifted_index', name: 'Lifted Index', unit: '', color: '#ef4444', type: 'line' },
                { id: 'convective_inhibition', name: 'CIN', unit: 'J/kg', color: '#f87171', type: 'line' },
                { id: 'boundary_layer_height', name: 'Gr√¶nselag h√∏jde', unit: 'm', color: '#fca5a5', type: 'line' }
            ]
        }
    },

    defaultVariables: ['temperature_2m', 'precipitation', 'wind_speed_10m', 'wind_gusts_10m', 'wind_direction_10m'],

    api: {
        openMeteo: 'https://api.open-meteo.com/v1/forecast',
        geocoding: 'https://geocoding-api.open-meteo.com/v1/search',
        rainviewer: 'https://api.rainviewer.com/public/weather-maps.json'
    },

    map: { center: [56.0, 10.5], zoom: 7 },
    cacheDuration: 5 * 60 * 1000,
    gridSize: 20,

    backgroundGradients: {
        night: 'linear-gradient(180deg, #0a0a1a 0%, #1a1a3a 30%, #2a2a4a 60%, #1a1a2a 100%)',
        dawn: 'linear-gradient(180deg, #2d1b4e 0%, #4a2c6a 20%, #8b5a8a 50%, #d4a574 80%, #f0c090 100%)',
        morning: 'linear-gradient(180deg, #a8c8e8 0%, #c8ddf0 20%, #e8f0f8 40%, #d8e8f4 70%, #b8d4e8 100%)',
        afternoon: 'linear-gradient(180deg, #87ceeb 0%, #b0e0f0 25%, #f0f8ff 50%, #fff8dc 80%, #ffe4b5 100%)',
        evening: 'linear-gradient(180deg, #1a1a3a 0%, #3a2a5a 20%, #6a4a7a 40%, #c87850 70%, #e8a070 100%)'
    },

    greetings: [
        'Tag dagen, som den kommer ‚Äì den har allerede m√∏dt dig.',
        'Der er ingen grund til at vinde dagen; det er nok at leve den.',
        'En rolig start kan b√¶re langt.',
        'Det er okay at begynde i det sm√•.',
        'Dagen skylder dig ingenting, men den rummer muligheder.',
        'Et venligt blik √¶ndrer mere, end man tror.',
        'Du beh√∏ver ikke have alle svarene i dag.',
        'Det er en god dag til at v√¶re til stede.',
        'Man kommer langt med lidt klarhed og lidt t√•lmodighed.',
        'Lad tempoet passe til opgaven ‚Äì ikke omvendt.',
        'Det er tilladt at tage dagen alvorligt uden at tage sig selv for h√∏jtideligt.',
        'En god start handler mere om retning end om fart.',
        'Nogle dage begynder bedst uden planer.',
        'Der er styrke i en enkel intention.',
        'Du m√• gerne tage √©n ting ad gangen.',
        'Dagen er ikke imod dig.',
        'Et lille skridt er stadig fremad.',
        'Det meste l√∏ser sig bedre i dagslys.',
        'En √•ben holdning g√∏r dagen lettere.',
        'Du har allerede klaret sv√¶rere ting end i dag.',
        'Ro smitter lige s√• meget som uro.',
        'Det er en god dag at v√¶re opm√¶rksom.',
        'Lad dagen udfolde sig, f√∏r du vurderer den.',
        'Der er ingen hast med at n√• frem.',
        'Det er nok at g√∏re sit bedste ‚Äì resten f√∏lger.',
        'Dagen kan b√¶re mere, end den lover.',
        'Start med det, der er lige foran dig.',
        'En god dag kr√¶ver ikke perfektion.',
        'Tag en ind√•nding ‚Äì du er allerede i gang.',
        'Der er plads til b√•de alvor og lethed i dag.'
    ]
};

// ============================================
// UTILITIES
// ============================================
const Utils = {
    debounce(fn, delay) {
        let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); };
    },
    formatTime(d) { return d.toLocaleTimeString('da-DK', { hour: '2-digit', minute: '2-digit' }); },
    formatDateShort(d) {
        const now = new Date();
        if (d.toDateString() === now.toDateString()) return 'I dag';
        return d.toLocaleDateString('da-DK', { weekday: 'short', day: 'numeric' });
    },
    getWeatherIcon(code, isDay = true) {
        const icons = { 0: isDay ? '‚òÄÔ∏è' : 'üåô', 1: isDay ? 'üå§Ô∏è' : 'üåô', 2: '‚õÖ', 3: '‚òÅÔ∏è',
            45: 'üå´Ô∏è', 48: 'üå´Ô∏è', 51: 'üåßÔ∏è', 53: 'üåßÔ∏è', 55: 'üåßÔ∏è', 61: 'üåßÔ∏è', 63: 'üåßÔ∏è', 65: 'üåßÔ∏è',
            71: 'üå®Ô∏è', 73: 'üå®Ô∏è', 75: '‚ùÑÔ∏è', 80: 'üåßÔ∏è', 81: 'üåßÔ∏è', 82: '‚õàÔ∏è', 95: '‚õàÔ∏è', 96: '‚õàÔ∏è', 99: '‚õàÔ∏è' };
        return icons[code] || 'üå°Ô∏è';
    },
    getWindDirection(deg) { return ['N','N√ò','√ò','S√ò','S','SV','V','NV'][Math.round(deg/45)%8]; },
    getWindArrow(deg) { return ['‚Üì','‚Üô','‚Üê','‚Üñ','‚Üë','‚Üó','‚Üí','‚Üò'][Math.round(deg/45)%8]; },
    generateId() { return 'p' + Math.random().toString(36).substr(2, 9); },
    snapToGrid(val) { return Math.round(val / Config.gridSize) * Config.gridSize; },
    storage: {
        get(k, d = null) { try { const v = localStorage.getItem('morgendis_' + k); return v ? JSON.parse(v) : d; } catch { return d; } },
        set(k, v) { try { localStorage.setItem('morgendis_' + k, JSON.stringify(v)); } catch {} }
    },
    getRandomGreeting() { return Config.greetings[Math.floor(Math.random() * Config.greetings.length)]; }
};

// ============================================
// TIME THEME
// ============================================
const TimeTheme = {
    current: null,
    manualTheme: null,
    getTheme(h) {
        if (h >= 22 || h < 5) return 'night';
        if (h >= 5 && h < 8) return 'dawn';
        if (h >= 8 && h < 12) return 'morning';
        if (h >= 12 && h < 17) return 'afternoon';
        return 'evening';
    },
    apply(theme) {
        if (theme === this.current) return;
        this.current = theme;
        document.body.setAttribute('data-time-theme', theme);
        const bg = document.getElementById('bg-layer');
        if (bg && Config.backgroundGradients[theme]) bg.style.background = Config.backgroundGradients[theme];
    },
    update() {
        const now = new Date();
        document.getElementById('current-time').textContent = Utils.formatTime(now);
        const theme = this.manualTheme || this.getTheme(now.getHours());
        this.apply(theme);
    },
    init() {
        document.getElementById('greeting-message').textContent = Utils.getRandomGreeting();
        this.manualTheme = null; // Always auto
        this.update();
        setInterval(() => this.update(), 60000);
    }
};

// ============================================
// WEATHER API
// ============================================
const WeatherAPI = {
    cache: new Map(),
    getCacheKey(lat, lon, model, days) { return `${lat.toFixed(3)}_${lon.toFixed(3)}_${model}_${days}`; },
    getFromCache(k) { const c = this.cache.get(k); return (c && Date.now() - c.ts < Config.cacheDuration) ? c.data : null; },
    setCache(k, d) { this.cache.set(k, { data: d, ts: Date.now() }); },

    async fetchForecast(city, model, days) {
        const k = this.getCacheKey(city.lat, city.lon, model, days);
        const cached = this.getFromCache(k);
        if (cached) return cached;

        // Request all possible variables
        const hourlyVars = [
            'temperature_2m', 'apparent_temperature', 'dew_point_2m', 'temperature_80m', 'temperature_120m', 'temperature_180m',
            'precipitation', 'rain', 'showers', 'snowfall', 'snow_depth', 'precipitation_probability', 'freezing_level_height',
            'wind_speed_10m', 'wind_speed_80m', 'wind_speed_120m', 'wind_speed_180m', 'wind_gusts_10m',
            'wind_direction_10m', 'wind_direction_80m', 'wind_direction_120m', 'wind_direction_180m',
            'surface_pressure', 'pressure_msl',
            'relative_humidity_2m', 'vapour_pressure_deficit', 'evapotranspiration',
            'cloud_cover', 'cloud_cover_low', 'cloud_cover_mid', 'cloud_cover_high', 'visibility',
            'uv_index', 'uv_index_clear_sky', 'sunshine_duration', 'shortwave_radiation', 'direct_radiation',
            'diffuse_radiation', 'direct_normal_irradiance', 'global_tilted_irradiance', 'terrestrial_radiation',
            'soil_temperature_0cm', 'soil_temperature_6cm', 'soil_temperature_18cm', 'soil_temperature_54cm',
            'soil_moisture_0_to_1cm', 'soil_moisture_1_to_3cm', 'soil_moisture_3_to_9cm', 'soil_moisture_9_to_27cm', 'soil_moisture_27_to_81cm',
            'cape', 'lifted_index', 'convective_inhibition', 'boundary_layer_height',
            'weather_code', 'is_day'
        ].join(',');

        const currentVars = 'temperature_2m,relative_humidity_2m,apparent_temperature,precipitation,weather_code,wind_speed_10m,wind_direction_10m,surface_pressure,cloud_cover';

        let url = `${Config.api.openMeteo}?latitude=${city.lat}&longitude=${city.lon}&hourly=${hourlyVars}&current=${currentVars}&wind_speed_unit=ms&timezone=auto&forecast_days=${days}`;
        if (model) url += `&models=${model}`;

        const res = await fetch(url);
        if (!res.ok) throw new Error(`API: ${res.status}`);
        const data = await res.json();
        if (data.error) throw new Error(data.reason || 'API error');
        this.setCache(k, data);
        return data;
    },

    async searchCities(q) {
        if (!q || q.length < 2) return [];
        const res = await fetch(`${Config.api.geocoding}?name=${encodeURIComponent(q)}&count=8&language=da&format=json`);
        if (!res.ok) return [];
        const d = await res.json();
        return d.results || [];
    },

    async fetchRadarData() {
        const res = await fetch(Config.api.rainviewer);
        if (!res.ok) throw new Error('Radar error');
        return res.json();
    }
};

// ============================================
// PANEL MANAGER (Auto-arrange, no overlap)
// ============================================
const PanelManager = {
    panels: new Map(),
    panelOrder: [], // Track order for arrangement
    gap: 10,

    init() {
        this.loadLayout();
        const debouncedResize = Utils.debounce(() => this.onWindowResize(), 300);
        window.addEventListener('resize', debouncedResize);
        screen.orientation?.addEventListener('change', () => setTimeout(debouncedResize, 200));
    },

    isMobile() { return window.innerWidth <= 768; },

    createPanel(type, config = {}) {
        const id = config.id || Utils.generateId();
        const panel = document.createElement('div');
        panel.className = 'panel';
        if (type === 'map') panel.classList.add('panel-map');
        panel.id = id;

        const mobile = this.isMobile();
        const ws = document.getElementById('workspace');
        const wsW = ws.clientWidth;
        const defaultW = Math.min(600, wsW - this.gap * 2);
        const w = config.w != null ? Math.min(config.w, wsW - this.gap * 2) : defaultW;
        const h = config.h != null ? config.h : (type === 'map' ? 400 : undefined);

        if (!mobile) {
            panel.style.width = w + 'px';
            if (type === 'map' && h) panel.style.height = h + 'px';
        }

        const title = config.title || (type === 'map' ? 'Radarkort' : config.cityName || 'Panel');

        panel.innerHTML = `
            <div class="panel-header">
                <h3>${title}${config.coords ? ` <span class="coords">${config.coords}</span>` : ''}</h3>
                <div class="panel-buttons">
                    <button class="btn-icon move-up-btn mobile-only" title="Flyt op">‚ñ≤</button>
                    <button class="btn-icon move-down-btn mobile-only" title="Flyt ned">‚ñº</button>
                    <button class="btn-icon minimize-btn" title="Minimer">‚àí</button>
                    <button class="btn-icon duplicate-btn" title="Dupliker">‚ßâ</button>
                    <button class="btn-icon danger close-btn" title="Luk">√ó</button>
                </div>
            </div>
            <div class="panel-content"></div>
            <div class="resize-handle"></div>
        `;

        ws.appendChild(panel);
        this.panels.set(id, { id, type, config, element: panel, minimized: false });
        this.panelOrder.push(id);

        if (!mobile) {
            this.setupDrag(id, panel);
            this.setupResize(id, panel, type);
        }

        panel.querySelector('.move-up-btn').addEventListener('click', () => this.movePanelUp(id));
        panel.querySelector('.move-down-btn').addEventListener('click', () => this.movePanelDown(id));
        panel.querySelector('.minimize-btn').addEventListener('click', () => this.toggleMinimize(id));
        panel.querySelector('.duplicate-btn').addEventListener('click', () => this.duplicatePanel(id));
        panel.querySelector('.close-btn').addEventListener('click', () => this.closePanel(id));
        // Clicking the title in the tray restores the panel
        panel.querySelector('.panel-header h3').addEventListener('click', () => {
            const p = this.panels.get(id);
            if (p && p.minimized) this.toggleMinimize(id);
        });

        return { id, panel, content: panel.querySelector('.panel-content') };
    },

    // Auto-arrange: pack panels top-to-bottom, fitting side-by-side when possible
    autoArrange() {
        if (this.isMobile()) return;
        const ws = document.getElementById('workspace');
        const wsW = ws.clientWidth;
        const gap = this.gap;

        // Collect panel dimensions in order
        const items = this.panelOrder
            .map(id => this.panels.get(id))
            .filter(p => p);

        // Simple row-packing: place panels in rows, fitting side-by-side
        let curX = gap, curY = gap, rowH = 0;
        items.forEach(p => {
            const el = p.element;
            const w = el.offsetWidth;
            const h = el.offsetHeight;

            // Does it fit in current row?
            if (curX + w + gap > wsW && curX > gap) {
                // Move to next row
                curX = gap;
                curY += rowH + gap;
                rowH = 0;
            }

            el.style.left = curX + 'px';
            el.style.top = curY + 'px';
            curX += w + gap;
            rowH = Math.max(rowH, h);
        });

        this.updateWorkspaceSize();
    },

    // Schedule auto-arrange after DOM settles
    scheduleArrange() {
        requestAnimationFrame(() => requestAnimationFrame(() => this.autoArrange()));
    },

    setupDrag(id, panel) {
        const header = panel.querySelector('.panel-header');
        let dragStart = null;
        let dragMoved = false;

        const onDragMove = (e) => {
            if (!dragStart) return;
            e.preventDefault();
            dragMoved = true;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            let newX = Math.max(0, dragStart.startX + clientX - dragStart.mouseX);
            let newY = Math.max(0, dragStart.startY + clientY - dragStart.mouseY);

            // Snap-to-edge logic
            const snap = 12;
            const gap = this.gap;
            const pw = panel.offsetWidth;
            const ph = panel.offsetHeight;
            const pl = newX, pr = newX + pw, pt = newY, pb = newY + ph;
            let snappedX = false, snappedY = false;

            // Snap to workspace edges
            if (Math.abs(pl - gap) < snap) { newX = gap; snappedX = true; }
            if (Math.abs(pt - gap) < snap) { newY = gap; snappedY = true; }

            // Snap to other panel edges
            this.panels.forEach((other, otherId) => {
                if (otherId === id) return;
                const oel = other.element;
                const ol = oel.offsetLeft, ot = oel.offsetTop;
                const or_ = ol + oel.offsetWidth, ob = ot + oel.offsetHeight;

                if (!snappedX) {
                    // Left edge ‚Üí other right edge + gap
                    if (Math.abs(pl - (or_ + gap)) < snap) { newX = or_ + gap; snappedX = true; }
                    // Right edge ‚Üí other left edge - gap
                    else if (Math.abs(pr - (ol - gap)) < snap) { newX = ol - gap - pw; snappedX = true; }
                    // Left‚ÜîLeft alignment
                    else if (Math.abs(pl - ol) < snap) { newX = ol; snappedX = true; }
                    // Right‚ÜîRight alignment
                    else if (Math.abs(pr - or_) < snap) { newX = or_ - pw; snappedX = true; }
                }
                if (!snappedY) {
                    // Top edge ‚Üí other bottom edge + gap
                    if (Math.abs(pt - (ob + gap)) < snap) { newY = ob + gap; snappedY = true; }
                    // Bottom edge ‚Üí other top edge - gap
                    else if (Math.abs(pb - (ot - gap)) < snap) { newY = ot - gap - ph; snappedY = true; }
                    // Top‚ÜîTop alignment
                    else if (Math.abs(pt - ot) < snap) { newY = ot; snappedY = true; }
                    // Bottom‚ÜîBottom alignment
                    else if (Math.abs(pb - ob) < snap) { newY = ob - ph; snappedY = true; }
                }
            });

            panel.style.left = Math.max(0, newX) + 'px';
            panel.style.top = Math.max(0, newY) + 'px';
            this.pushNeighbors(id);
        };

        const onDragEnd = () => {
            if (!dragStart) return;
            panel.classList.remove('dragging');
            document.removeEventListener('mousemove', onDragMove);
            document.removeEventListener('mouseup', onDragEnd);
            document.removeEventListener('touchmove', onDragMove);
            document.removeEventListener('touchend', onDragEnd);

            if (dragMoved) {
                this.pushNeighbors(id);
                // Update panelOrder based on position without rearranging
                const dropY = panel.offsetTop;
                const dropX = panel.offsetLeft;
                const oldIdx = this.panelOrder.indexOf(id);
                this.panelOrder.splice(oldIdx, 1);
                let insertIdx = this.panelOrder.length;
                for (let i = 0; i < this.panelOrder.length; i++) {
                    const other = this.panels.get(this.panelOrder[i]);
                    if (!other) continue;
                    const oy = other.element.offsetTop;
                    const ox = other.element.offsetLeft;
                    if (dropY < oy || (dropY === oy && dropX < ox)) {
                        insertIdx = i;
                        break;
                    }
                }
                this.panelOrder.splice(insertIdx, 0, id);
                this.updateWorkspaceSize();
                this.saveLayout();
            }

            dragStart = null;
            dragMoved = false;
        };

        const onDragStart = (e) => {
            if (e.target.closest('.panel-buttons')) return;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            dragStart = {
                mouseX: clientX,
                mouseY: clientY,
                startX: panel.offsetLeft,
                startY: panel.offsetTop
            };
            dragMoved = false;
            panel.classList.add('dragging');
            panel.style.zIndex = 999;
            document.addEventListener('mousemove', onDragMove);
            document.addEventListener('mouseup', onDragEnd);
            document.addEventListener('touchmove', onDragMove, { passive: false });
            document.addEventListener('touchend', onDragEnd);
        };

        header.addEventListener('mousedown', onDragStart);
        header.addEventListener('touchstart', onDragStart, { passive: false });
    },

    setupResize(id, panel, type) {
        const handle = panel.querySelector('.resize-handle');
        const canResizeHeight = type === 'map';
        let resizeStart = null;

        const onResizeMove = (e) => {
            if (!resizeStart) return;
            e.preventDefault();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const wsW = document.getElementById('workspace').clientWidth;
            const newW = Math.min(wsW - this.gap * 2, Math.max(280, resizeStart.w + clientX - resizeStart.mouseX));
            panel.style.width = Utils.snapToGrid(newW) + 'px';
            if (canResizeHeight) {
                const newH = Math.max(200, resizeStart.h + clientY - resizeStart.mouseY);
                panel.style.height = Utils.snapToGrid(newH) + 'px';
            }
            // Shrink overlapping neighbors in real-time
            this.shrinkOverlapping(id);
        };

        const onResizeEnd = () => {
            if (!resizeStart) return;
            resizeStart = null;
            document.removeEventListener('mousemove', onResizeMove);
            document.removeEventListener('mouseup', onResizeEnd);
            document.removeEventListener('touchmove', onResizeMove);
            document.removeEventListener('touchend', onResizeEnd);
            this.shrinkOverlapping(id);
            this.updateWorkspaceSize();
            this.saveLayout();
        };

        const onResizeStart = (e) => {
            e.preventDefault();
            e.stopPropagation();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            resizeStart = {
                mouseX: clientX,
                mouseY: clientY,
                w: panel.offsetWidth,
                h: panel.offsetHeight
            };
            document.addEventListener('mousemove', onResizeMove);
            document.addEventListener('mouseup', onResizeEnd);
            document.addEventListener('touchmove', onResizeMove, { passive: false });
            document.addEventListener('touchend', onResizeEnd);
        };

        handle.addEventListener('mousedown', onResizeStart);
        handle.addEventListener('touchstart', onResizeStart, { passive: false });
    },

    movePanelUp(id) {
        const el = this.panels.get(id)?.element;
        if (!el) return;
        const prev = el.previousElementSibling;
        if (prev && prev.classList.contains('panel')) {
            el.parentNode.insertBefore(el, prev);
            // Update panelOrder
            const idx = this.panelOrder.indexOf(id);
            if (idx > 0) {
                [this.panelOrder[idx - 1], this.panelOrder[idx]] = [this.panelOrder[idx], this.panelOrder[idx - 1]];
            }
            this.saveLayout();
        }
    },

    movePanelDown(id) {
        const el = this.panels.get(id)?.element;
        if (!el) return;
        const next = el.nextElementSibling;
        if (next && next.classList.contains('panel')) {
            el.parentNode.insertBefore(next, el);
            // Update panelOrder
            const idx = this.panelOrder.indexOf(id);
            if (idx < this.panelOrder.length - 1) {
                [this.panelOrder[idx], this.panelOrder[idx + 1]] = [this.panelOrder[idx + 1], this.panelOrder[idx]];
            }
            this.saveLayout();
        }
    },

    updateWorkspaceSize() {
        const ws = document.getElementById('workspace');
        let maxBottom = window.innerHeight - 50;
        this.panels.forEach(p => {
            if (p.minimized) return;
            const bottom = p.element.offsetTop + p.element.offsetHeight + 20;
            if (bottom > maxBottom) maxBottom = bottom;
        });
        ws.style.minHeight = maxBottom + 'px';
    },

    rectsOverlap(a, b) {
        return a.l < b.r && a.r > b.l && a.t < b.b && a.b > b.t;
    },

    resolveOverlap(id) {
        const p = this.panels.get(id);
        if (!p) return;
        const el = p.element;
        const gap = this.gap;
        const wsW = document.getElementById('workspace').clientWidth;
        let attempts = 0;

        while (attempts < 50) {
            const rect = { l: el.offsetLeft, t: el.offsetTop, r: el.offsetLeft + el.offsetWidth, b: el.offsetTop + el.offsetHeight };
            let overlap = false;

            for (const [otherId, other] of this.panels) {
                if (otherId === id) continue;
                const oel = other.element;
                const oRect = { l: oel.offsetLeft, t: oel.offsetTop, r: oel.offsetLeft + oel.offsetWidth, b: oel.offsetTop + oel.offsetHeight };
                if (this.rectsOverlap(rect, oRect)) {
                    overlap = true;
                    // Try pushing right
                    const newX = oRect.r + gap;
                    if (newX + el.offsetWidth + gap <= wsW) {
                        el.style.left = newX + 'px';
                    } else {
                        // Push down, reset to left
                        el.style.left = gap + 'px';
                        el.style.top = (oRect.b + gap) + 'px';
                    }
                    break;
                }
            }
            if (!overlap) break;
            attempts++;
        }
    },

    shrinkOverlapping(id) {
        const p = this.panels.get(id);
        if (!p) return;
        const el = p.element;
        const gap = this.gap;
        const wsW = document.getElementById('workspace').clientWidth;
        const rect = { l: el.offsetLeft, t: el.offsetTop, r: el.offsetLeft + el.offsetWidth, b: el.offsetTop + el.offsetHeight };

        for (const [otherId, other] of this.panels) {
            if (otherId === id || other.minimized) continue;
            const oel = other.element;
            const ol = oel.offsetLeft, ot = oel.offsetTop;
            const ow = oel.offsetWidth, oh = oel.offsetHeight;

            // Only act on panels that overlap vertically
            if (ot + oh <= rect.t || ot >= rect.b) continue;

            // Neighbor is to the right: push it, then shrink if hitting workspace edge
            if (ol >= rect.l && ol < rect.r + gap) {
                const newLeft = rect.r + gap;
                if (newLeft === ol) continue; // already in place
                const maxRight = wsW - gap;
                if (newLeft + ow <= maxRight) {
                    // Just push, keep width
                    oel.style.left = newLeft + 'px';
                } else {
                    // Push and shrink against workspace edge
                    const newW = maxRight - newLeft;
                    if (newW >= 280) {
                        oel.style.left = newLeft + 'px';
                        oel.style.width = newW + 'px';
                    }
                }
            }
        }
    },

    pushNeighbors(id) {
        const p = this.panels.get(id);
        if (!p) return;
        const el = p.element;
        const gap = this.gap;
        const wsW = document.getElementById('workspace').clientWidth;
        const pl = el.offsetLeft, pt = el.offsetTop;
        const pr = pl + el.offsetWidth, pb = pt + el.offsetHeight;

        for (const [otherId, other] of this.panels) {
            if (otherId === id || other.minimized) continue;
            const oel = other.element;
            const ol = oel.offsetLeft, ot = oel.offsetTop;
            const ow = oel.offsetWidth, oh = oel.offsetHeight;
            const or_ = ol + ow, ob = ot + oh;

            // Check actual pixel overlap
            if (!(pl < or_ && pr > ol && pt < ob && pb > ot)) continue;

            // How much to push to restore gap in each direction
            const pushR = pr + gap - ol;
            const pushL = or_ + gap - pl;
            const pushD = pb + gap - ot;
            const pushU = ob + gap - pt;

            // Push in direction of least penetration
            const minH = Math.min(pushR, pushL);
            const minV = Math.min(pushD, pushU);

            if (minH <= minV) {
                if (pushR <= pushL) {
                    const newLeft = pr + gap;
                    oel.style.left = Math.min(newLeft, wsW - gap - ow) + 'px';
                } else {
                    const newLeft = pl - gap - ow;
                    oel.style.left = Math.max(gap, newLeft) + 'px';
                }
            } else {
                if (pushD <= pushU) {
                    oel.style.top = (pb + gap) + 'px';
                } else {
                    const newTop = pt - gap - oh;
                    oel.style.top = Math.max(gap, newTop) + 'px';
                }
            }
        }
    },

    toggleMinimize(id) {
        const p = this.panels.get(id);
        if (!p) return;
        p.minimized = !p.minimized;
        p.element.classList.toggle('minimized', p.minimized);
        p.element.querySelector('.minimize-btn').textContent = p.minimized ? '+' : '‚àí';

        const h3 = p.element.querySelector('.panel-header h3');
        if (p.minimized) {
            p.originalTitle = h3.innerHTML;
            if (p.type === 'city') {
                const summary = CityCards.getCurrentValuesSummary(id);
                h3.innerHTML = `${p.config.city?.name || 'Panel'} <span class="minimized-vars">${summary}</span>`;
            } else if (p.type === 'map') {
                h3.innerHTML = 'Radarkort';
            }
        } else if (p.originalTitle) {
            h3.innerHTML = p.originalTitle;
        }

        this.updateWorkspaceSize();
        this.saveLayout();
    },

    duplicatePanel(id) {
        const p = this.panels.get(id);
        if (!p) return;
        const newConfig = { ...p.config, id: null };
        if (p.type === 'city') {
            CityCards.createCityPanel(newConfig.city, newConfig);
        } else if (p.type === 'map') {
            MapModule.createMapPanel(newConfig);
        }
        this.scheduleArrange();
        this.saveLayout();
    },

    closePanel(id) {
        const p = this.panels.get(id);
        if (!p) return;
        if (p.type === 'city') CityCards.removeCity(id);
        else if (p.type === 'map') MapModule.removeMap(id);
        p.element.remove();
        this.panels.delete(id);
        this.panelOrder = this.panelOrder.filter(pid => pid !== id);
        this.updateWorkspaceSize();
        this.saveLayout();
    },


    onWindowResize() {
        MapModule.invalidateAllMaps();
        CityCards.reRenderAll();
        if (!this.isMobile()) {
            // Clamp widths to fit viewport
            const wsW = document.getElementById('workspace').clientWidth;
            this.panels.forEach(p => {
                const maxW = wsW - this.gap * 2;
                if (p.element.offsetWidth > maxW) {
                    p.element.style.width = maxW + 'px';
                }
            });
            this.autoArrange();
        }
    },

    saveLayout() {
        if (this.isMobile()) return;
        const layout = [];
        this.panelOrder.forEach(id => {
            const p = this.panels.get(id);
            if (!p) return;
            const entry = {
                id, type: p.type, config: p.config, minimized: p.minimized,
                w: p.element.offsetWidth,
                x: p.element.offsetLeft, y: p.element.offsetTop
            };
            if (p.type === 'map') entry.h = p.element.offsetHeight;
            layout.push(entry);
        });
        Utils.storage.set('layout', layout);
    },

    createDefaultLayout() {
        const ws = document.getElementById('workspace');
        const wsW = ws.clientWidth;
        const gap = this.gap;
        const mobile = this.isMobile();

        if (mobile) {
            const panelW = wsW - gap * 2;
            MapModule.createMapPanel({ w: panelW, h: 400 });
            Config.defaultCities.forEach(city => CityCards.createCityPanel(city, { w: panelW }));
            return;
        }

        // Desktop: city panels left, map right
        const cityW = Math.min(600, Math.floor((wsW - gap * 3) * 0.55));
        const mapW = wsW - cityW - gap * 3;
        const mapH = 500;

        // Create city panels first (left column)
        Config.defaultCities.forEach(city => CityCards.createCityPanel(city, { w: cityW }));

        // Create map panel (right side)
        MapModule.createMapPanel({ w: mapW, h: mapH });

        // Position: cities stacked left, map top-right
        setTimeout(() => {
            let curY = gap;
            this.panelOrder.forEach(id => {
                const p = this.panels.get(id);
                if (!p) return;
                if (p.type === 'city') {
                    p.element.style.left = gap + 'px';
                    p.element.style.top = curY + 'px';
                    curY += p.element.offsetHeight + gap;
                } else if (p.type === 'map') {
                    p.element.style.left = (cityW + gap * 2) + 'px';
                    p.element.style.top = gap + 'px';
                }
            });
            this.updateWorkspaceSize();
            this.saveLayout();
        }, 500);
    },

    loadLayout() {
        const layout = Utils.storage.get('layout');
        if (!layout || layout.length === 0) {
            this.createDefaultLayout();
            return;
        } else {
            const hasPositions = layout.every(l => l.x != null && l.y != null);
            layout.forEach(l => {
                const cfg = { ...l.config, w: l.w };
                if (l.type === 'map') {
                    cfg.h = l.h || 400;
                    MapModule.createMapPanel(cfg);
                } else if (l.type === 'city') {
                    CityCards.createCityPanel(l.config.city, cfg);
                }
                // Restore saved position
                const lastId = this.panelOrder[this.panelOrder.length - 1];
                if (lastId && l.x != null && l.y != null) {
                    const el = this.panels.get(lastId)?.element;
                    if (el) {
                        el.style.left = l.x + 'px';
                        el.style.top = l.y + 'px';
                    }
                }
                // Restore minimized state
                if (l.minimized && l.id) {
                    if (lastId) this.toggleMinimize(lastId);
                }
            });
            if (hasPositions) {
                setTimeout(() => this.updateWorkspaceSize(), 500);
                return;
            }
        }
        // Auto-arrange after all panels are created and content loaded
        setTimeout(() => { this.autoArrange(); this.saveLayout(); }, 500);
    }
};

// ============================================
// MAP MODULE
// ============================================
const MapModule = {
    maps: new Map(),
    radarFrames: [],
    radarLayers: new Map(),

    createMapPanel(config = {}) {
        const { id, panel, content } = PanelManager.createPanel('map', { ...config, title: 'Radarkort' });

        content.innerHTML = `
            <div id="map-${id}" style="flex:1;min-height:200px;"></div>
            <div class="map-controls">
                <div class="radar-controls">
                    <button class="btn play-btn">‚è∏</button>
                    <input type="range" class="frame-slider" min="0" max="0" value="0">
                    <span class="timestamp">--:--</span>
                </div>
                <div class="layer-toggles">
                    <label><input type="checkbox" class="toggle-radar" checked> Radar</label>
                    <label><input type="checkbox" class="toggle-labels" checked> Navne</label>
                    <label><input type="checkbox" class="toggle-temp" checked> Temp</label>
                </div>
            </div>
        `;

        setTimeout(() => this.initMap(id, content), 100);
        return id;
    },

    initMap(id, content) {
        const mapEl = content.querySelector(`#map-${id}`);
        const map = L.map(mapEl, { center: Config.map.center, zoom: Config.map.zoom, minZoom: 5, maxZoom: 12 });
        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { attribution: '¬© CARTO', subdomains: 'abcd' }).addTo(map);

        const mapData = { map, layers: [], currentFrame: 0, isPlaying: true, interval: null, showLabels: true, showTemp: true, radarEnabled: true, markers: new Map(), resizeObserver: null };
        this.maps.set(id, mapData);

        this.initRadar(id, content);
        this.setupMapControls(id, content);
        this.addCityMarkersToMap(id);

        // Fix map size after panel resize using ResizeObserver
        setTimeout(() => map.invalidateSize(), 200);

        // Watch for panel resize and invalidate map
        const panel = content.closest('.panel');
        if (panel) {
            mapData.resizeObserver = new ResizeObserver(() => {
                map.invalidateSize();
            });
            mapData.resizeObserver.observe(panel);
        }
    },

    async initRadar(id, content) {
        try {
            if (this.radarFrames.length === 0) {
                const data = await WeatherAPI.fetchRadarData();
                this.radarFrames = data.radar.past.concat(data.radar.nowcast || []);
            }

            const mapData = this.maps.get(id);
            if (!mapData || this.radarFrames.length === 0) return;

            // Create radar layers
            this.radarFrames.forEach((frame, i) => {
                const url = `https://tilecache.rainviewer.com${frame.path}/256/{z}/{x}/{y}/2/1_1.png`;
                const layer = L.tileLayer(url, { opacity: 0, zIndex: 100 + i });
                layer.addTo(mapData.map);
                mapData.layers.push(layer);
            });

            const slider = content.querySelector('.frame-slider');
            slider.max = this.radarFrames.length - 1;
            slider.value = this.radarFrames.length - 1;
            mapData.currentFrame = this.radarFrames.length - 1;

            this.showRadarFrame(id, mapData.currentFrame, content);
            this.startAutoPlay(id, content);
        } catch (e) { console.error('Radar error:', e); }
    },

    showRadarFrame(id, index, content) {
        const mapData = this.maps.get(id);
        if (!mapData) return;
        const opacity = mapData.radarEnabled ? 0.7 : 0;
        mapData.layers.forEach((l, i) => l.setOpacity(i === index ? opacity : 0));
        if (this.radarFrames[index]) {
            content.querySelector('.timestamp').textContent = Utils.formatTime(new Date(this.radarFrames[index].time * 1000));
        }
    },

    startAutoPlay(id, content) {
        const mapData = this.maps.get(id);
        if (!mapData) return;
        if (mapData.interval) clearInterval(mapData.interval);
        mapData.isPlaying = true;
        content.querySelector('.play-btn').textContent = '‚è∏';
        mapData.interval = setInterval(() => {
            mapData.currentFrame = (mapData.currentFrame + 1) % this.radarFrames.length;
            content.querySelector('.frame-slider').value = mapData.currentFrame;
            this.showRadarFrame(id, mapData.currentFrame, content);
        }, 700);
    },

    stopAutoPlay(id, content) {
        const mapData = this.maps.get(id);
        if (!mapData) return;
        if (mapData.interval) clearInterval(mapData.interval);
        mapData.isPlaying = false;
        content.querySelector('.play-btn').textContent = '‚ñ∂';
    },

    setupMapControls(id, content) {
        const mapData = this.maps.get(id);
        content.querySelector('.play-btn').addEventListener('click', () => {
            if (mapData.isPlaying) this.stopAutoPlay(id, content);
            else this.startAutoPlay(id, content);
        });
        content.querySelector('.frame-slider').addEventListener('input', (e) => {
            this.stopAutoPlay(id, content);
            mapData.currentFrame = parseInt(e.target.value);
            this.showRadarFrame(id, mapData.currentFrame, content);
        });
        content.querySelector('.toggle-radar').addEventListener('change', (e) => {
            if (e.target.checked) {
                mapData.layers[mapData.currentFrame]?.setOpacity(0.7);
                mapData.radarEnabled = true;
            } else {
                mapData.layers.forEach(l => l.setOpacity(0));
                mapData.radarEnabled = false;
                this.stopAutoPlay(id, content);
            }
        });
        content.querySelector('.toggle-labels').addEventListener('change', (e) => {
            mapData.showLabels = e.target.checked;
            this.updateMapMarkers(id);
        });
        content.querySelector('.toggle-temp').addEventListener('change', (e) => {
            mapData.showTemp = e.target.checked;
            this.updateMapMarkers(id);
        });
    },

    addCityMarkersToMap(mapId) {
        const mapData = this.maps.get(mapId);
        if (!mapData) return;
        CityCards.cities.forEach((city, cityId) => {
            this.addCityMarker(mapId, city);
        });
        // Apply any weather data that already arrived before the map initialized
        CityCards.weatherData.forEach((data, panelId) => {
            const p = PanelManager.panels.get(panelId);
            if (p && p.config.city) {
                const m = mapData.markers.get(p.config.city.id);
                if (m && !m.weather) {
                    m.weather = data;
                    this.updateMarkerContent(mapId, m);
                }
            }
        });
    },

    addCityMarker(mapId, city) {
        const mapData = this.maps.get(mapId);
        if (!mapData) return;
        if (mapData.markers.has(city.id)) return;
        const icon = L.divIcon({
            className: 'leaflet-div-icon',
            html: `<div class="city-marker-label"><div class="name">${city.name}</div></div>`,
            iconSize: [0, 0], iconAnchor: [0, 0]
        });
        const marker = L.marker([city.lat, city.lon], { icon, interactive: false }).addTo(mapData.map);
        mapData.markers.set(city.id, { marker, city, weather: null });
    },

    updateCityMarkerWeather(cityId, weather) {
        this.maps.forEach((mapData, mapId) => {
            const m = mapData.markers.get(cityId);
            if (m) {
                m.weather = weather;
                this.updateMarkerContent(mapId, m);
            }
        });
    },

    buildMarkerHtml(mapData, markerData) {
        const w = markerData.weather?.current;
        let html = '<div class="city-marker-label">';
        if (mapData.showLabels) html += `<div class="name">${markerData.city.name}</div>`;
        if (w && (mapData.showLabels || mapData.showTemp)) html += '<div class="sep"></div>';
        if (w && mapData.showTemp) {
            html += `<span class="weather-icon">${Utils.getWeatherIcon(w.weather_code)}</span>`;
            html += `<span class="temp">${Math.round(w.temperature_2m)}¬∞</span>`;
        }
        if (w && mapData.showLabels) {
            html += `<span class="wind">${w.wind_speed_10m?.toFixed(0) || 0} m/s</span>`;
        }
        html += '</div>';
        return html;
    },

    updateMarkerContent(mapId, markerData) {
        const mapData = this.maps.get(mapId);
        if (!mapData) return;
        const el = markerData.marker.getElement();
        if (!el) return;
        const show = mapData.showLabels || mapData.showTemp;
        el.style.display = show ? 'block' : 'none';
        if (show) el.innerHTML = this.buildMarkerHtml(mapData, markerData);
    },

    updateMapMarkers(mapId) {
        const mapData = this.maps.get(mapId);
        if (!mapData) return;
        mapData.markers.forEach(m => this.updateMarkerContent(mapId, m));
    },

    removeMap(id) {
        const mapData = this.maps.get(id);
        if (mapData) {
            if (mapData.interval) clearInterval(mapData.interval);
            if (mapData.resizeObserver) mapData.resizeObserver.disconnect();
            mapData.map.remove();
            this.maps.delete(id);
        }
    },

    invalidateAllMaps() {
        this.maps.forEach(m => m.map.invalidateSize());
    }
};

// ============================================
// CITY CARDS
// ============================================
const CityCards = {
    cities: new Map(),
    charts: new Map(),
    selectedVariables: new Set(Config.defaultVariables),
    weatherData: new Map(),

    init() {
        const savedVars = Utils.storage.get('selectedVariables');
        if (savedVars) this.selectedVariables = new Set(savedVars);
    },

    getCurrentValuesSummary(panelId) {
        const data = this.weatherData.get(panelId);
        if (!data?.current) return '';
        const c = data.current;
        const parts = [];
        if (c.temperature_2m != null) parts.push(`${Math.round(c.temperature_2m)}¬∞`);
        if (c.wind_speed_10m != null) parts.push(`${c.wind_speed_10m.toFixed(1)} m/s`);
        if (c.precipitation > 0) parts.push(`${c.precipitation} mm`);
        if (c.relative_humidity_2m != null) parts.push(`${c.relative_humidity_2m}%`);
        return parts.join(' ¬∑ ');
    },

    createCityPanel(city, config = {}) {
        const cityWithId = { ...city, id: city.id || Utils.generateId() };
        this.cities.set(cityWithId.id, cityWithId);

        const { id, panel, content } = PanelManager.createPanel('city', {
            ...config,
            city: cityWithId,
            title: cityWithId.name,
            coords: `${cityWithId.lat.toFixed(2)}¬∞N, ${cityWithId.lon.toFixed(2)}¬∞√ò`
        });

        content.innerHTML = `
            <div class="current-weather" id="current-${id}"><div class="loading-indicator">Henter...</div></div>
            <details class="variable-selector">
                <summary>V√¶lg variabler</summary>
                <div class="variable-groups" id="vars-${id}">${this.renderVariableSelector()}</div>
            </details>
            <div class="forecast-container" id="forecast-${id}"><div class="loading-indicator">Henter prognose...</div></div>
        `;

        this.setupCardEvents(id, cityWithId, content);
        this.fetchAndRender(id, cityWithId);

        // Add to all maps
        MapModule.maps.forEach((_, mapId) => MapModule.addCityMarker(mapId, cityWithId));

        return id;
    },

    renderVariableSelector() {
        let html = '';
        for (const [key, group] of Object.entries(Config.variableGroups)) {
            html += `<div class="variable-group"><h4>${group.icon} ${group.name}</h4>`;
            for (const v of group.variables) {
                const checked = this.selectedVariables.has(v.id) ? 'checked' : '';
                html += `<label><input type="checkbox" value="${v.id}" ${checked}>${v.name}</label>`;
            }
            html += '</div>';
        }
        return html;
    },

    setupCardEvents(panelId, city, content) {
        content.querySelector('.variable-groups').addEventListener('change', (e) => {
            if (e.target.type === 'checkbox') {
                const varId = e.target.value;
                if (e.target.checked) this.selectedVariables.add(varId);
                else this.selectedVariables.delete(varId);
                Utils.storage.set('selectedVariables', [...this.selectedVariables]);
                const data = this.weatherData.get(panelId);
                if (data) {
                    this.renderDetailedForecast(panelId, city, data);
                    PanelManager.scheduleArrange();
                }
            }
        });

        // Watch for panel resize and update charts
        const panel = content.closest('.panel');
        if (panel) {
            let resizeTimeout;
            const resizeObserver = new ResizeObserver(() => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    this.charts.forEach((chart, key) => {
                        if (key.endsWith(panelId)) chart.resize();
                    });
                }, 100);
            });
            resizeObserver.observe(panel);
            // Store for cleanup
            if (!this.resizeObservers) this.resizeObservers = new Map();
            this.resizeObservers.set(panelId, resizeObserver);
        }
    },

    async fetchAndRender(panelId, city) {
        const model = '';
        const days = 9; // Always fetch 9 days, time window filtered in render

        try {
            const data = await WeatherAPI.fetchForecast(city, model, days);
            this.weatherData.set(panelId, data);
            this.renderCurrentWeather(panelId, data.current);
            this.renderDetailedForecast(panelId, city, data);
            MapModule.updateCityMarkerWeather(city.id, data);
            document.getElementById('last-update').textContent = `Opdateret: ${Utils.formatTime(new Date())}`;
            PanelManager.updateWorkspaceSize();
        } catch (e) {
            console.error(`Error for ${city.name}:`, e);
            document.getElementById(`current-${panelId}`).innerHTML = `<div class="error-message">Fejl: ${e.message}</div>`;
        }
    },

    renderCurrentWeather(panelId, current) {
        const el = document.getElementById(`current-${panelId}`);
        if (!current) { el.innerHTML = '<div class="error-message">Ingen data</div>'; return; }
        const icon = Utils.getWeatherIcon(current.weather_code, true);
        const windDir = Utils.getWindDirection(current.wind_direction_10m || 0);
        el.innerHTML = `
            <div class="weather-icon">${icon}</div>
            <div class="temp-display">
                <div class="temp-value">${Math.round(current.temperature_2m)}¬∞</div>
                <div class="feels-like">F√∏les som ${Math.round(current.apparent_temperature)}¬∞</div>
            </div>
            <div class="weather-details">
                <div class="detail-item"><span class="detail-label">Vind</span><span class="detail-value">${(current.wind_speed_10m || 0).toFixed(1)} m/s ${windDir}</span></div>
                <div class="detail-item"><span class="detail-label">Fugtighed</span><span class="detail-value">${current.relative_humidity_2m || 0}%</span></div>
                <div class="detail-item"><span class="detail-label">Tryk</span><span class="detail-value">${Math.round(current.surface_pressure || 0)} hPa</span></div>
                <div class="detail-item"><span class="detail-label">Skyer</span><span class="detail-value">${current.cloud_cover || 0}%</span></div>
            </div>
        `;
    },

    renderDetailedForecast(panelId, city, data) {
        const container = document.getElementById(`forecast-${panelId}`);
        const hourly = data.hourly;
        const allTimes = hourly.time.map(t => new Date(t));

        // Determine time window based on forecast mode
        const mode = Utils.storage.get('forecastMode', '48h');
        const now = new Date();
        now.setMinutes(0, 0, 0);

        let startIdx = 0;
        for (let i = 0; i < allTimes.length; i++) {
            if (allTimes[i] >= now) { startIdx = i; break; }
        }

        // Calculate end index based on mode
        let endIdx = allTimes.length;
        if (mode === '48h') {
            // Show 48 hours from now
            const end48 = new Date(now.getTime() + 48 * 3600000);
            for (let i = startIdx; i < allTimes.length; i++) {
                if (allTimes[i] > end48) { endIdx = i; break; }
            }
        } else {
            // Show from +48h to +192h (days 3-9)
            const start48 = new Date(now.getTime() + 48 * 3600000);
            const end192 = new Date(now.getTime() + 192 * 3600000);
            for (let i = startIdx; i < allTimes.length; i++) {
                if (allTimes[i] >= start48) { startIdx = i; break; }
            }
            for (let i = startIdx; i < allTimes.length; i++) {
                if (allTimes[i] > end192) { endIdx = i; break; }
            }
        }

        const times = allTimes.slice(startIdx, endIdx);
        const totalHours = times.length;

        // Find day boundaries
        const days = [];
        let currentDay = null;
        times.forEach((t, i) => {
            const dk = t.toDateString();
            if (dk !== currentDay) { days.push({ date: t, start: i + startIdx, end: i + startIdx }); currentDay = dk; }
            else days[days.length - 1].end = i + startIdx;
        });

        // Compact labels: increase step when many hours or on mobile
        const mobile = window.innerWidth <= 768;
        let step = 2;
        if (totalHours > 72) step = 6;
        else if (totalHours > 48 || mobile) step = 3;
        const displayIndices = [];
        for (let i = startIdx; i < endIdx; i += step) displayIndices.push(i);

        let html = '<div class="forecast-wrapper" id="fw-' + panelId + '">';

        // Day headers
        html += '<div class="day-headers">';
        days.forEach(d => {
            const w = ((d.end - d.start + 1) / times.length) * 100;
            const isToday = d.date.toDateString() === new Date().toDateString();
            html += `<div class="day-header${isToday ? ' today' : ''}" style="flex:${w}">${Utils.formatDateShort(d.date)}</div>`;
        });
        html += '</div>';

        // Weather icons
        html += '<div class="weather-icons-row">';
        displayIndices.forEach(i => {
            const code = hourly.weather_code?.[i] || 0;
            const isDay = hourly.is_day ? hourly.is_day[i] : true;
            html += `<div class="weather-icon-cell">${Utils.getWeatherIcon(code, isDay)}</div>`;
        });
        html += '</div>';

        // Group variables by chart type
        const chartGroups = {
            tempPrecip: { vars: [], tempVars: [], precipVars: [], labelLeft: '¬∞C', labelRight: 'mm', height: 'temp' },
            wind: { vars: [], label: 'm/s', height: 'wind' },
            pressure: { vars: [], label: 'hPa', height: 'pressure' },
            humidity: { vars: [], label: '%', height: 'humidity' },
            clouds: { vars: [], label: '%', height: 'clouds' },
            solar: { vars: [], label: 'W/m¬≤', height: 'solar' }
        };

        // Map variables to chart groups
        const varToGroup = {
            temperature_2m: 'tempPrecip:temp', apparent_temperature: 'tempPrecip:temp', dew_point_2m: 'tempPrecip:temp',
            temperature_80m: 'tempPrecip:temp', temperature_120m: 'tempPrecip:temp', temperature_180m: 'tempPrecip:temp',
            soil_temperature_0cm: 'tempPrecip:temp', soil_temperature_6cm: 'tempPrecip:temp', soil_temperature_18cm: 'tempPrecip:temp', soil_temperature_54cm: 'tempPrecip:temp',
            precipitation: 'tempPrecip:precip', rain: 'tempPrecip:precip', showers: 'tempPrecip:precip', snowfall: 'tempPrecip:precip',
            precipitation_probability: 'tempPrecip:precip', evapotranspiration: 'tempPrecip:precip',
            wind_speed_10m: 'wind', wind_speed_80m: 'wind', wind_speed_120m: 'wind', wind_speed_180m: 'wind', wind_gusts_10m: 'wind',
            surface_pressure: 'pressure', pressure_msl: 'pressure',
            relative_humidity_2m: 'humidity', vapour_pressure_deficit: 'humidity',
            cloud_cover: 'clouds', cloud_cover_low: 'clouds', cloud_cover_mid: 'clouds', cloud_cover_high: 'clouds', visibility: 'clouds',
            uv_index: 'solar', uv_index_clear_sky: 'solar', sunshine_duration: 'solar',
            shortwave_radiation: 'solar', direct_radiation: 'solar', diffuse_radiation: 'solar',
            direct_normal_irradiance: 'solar', global_tilted_irradiance: 'solar', terrestrial_radiation: 'solar'
        };

        // Build variable lookup
        const allVars = {};
        Object.values(Config.variableGroups).forEach(g => g.variables.forEach(v => allVars[v.id] = v));

        // Assign selected variables to groups
        this.selectedVariables.forEach(varId => {
            const groupMapping = varToGroup[varId];
            if (!groupMapping || !hourly[varId]) return;

            if (groupMapping.includes(':')) {
                const [group, subType] = groupMapping.split(':');
                chartGroups[group].vars.push(varId);
                if (subType === 'temp') chartGroups[group].tempVars.push(varId);
                else if (subType === 'precip') chartGroups[group].precipVars.push(varId);
            } else {
                chartGroups[groupMapping].vars.push(varId);
            }
        });

        // Render charts for each group with data - ALL charts get both y-label and y-label-right for alignment
        Object.entries(chartGroups).forEach(([groupKey, group]) => {
            if (group.vars.length === 0) return;
            html += `<div class="chart-section chart-container-${group.height}">`;
            if (groupKey === 'tempPrecip') {
                html += `<span class="y-label">${group.labelLeft}</span>`;
                html += `<div class="chart-canvas-wrapper"><canvas id="chart-${groupKey}-${panelId}"></canvas></div>`;
                html += `<span class="y-label-right">${group.labelRight}</span>`;
            } else {
                html += `<span class="y-label">${group.label}</span>`;
                html += `<div class="chart-canvas-wrapper"><canvas id="chart-${groupKey}-${panelId}"></canvas></div>`;
                html += `<span class="y-label-right">&nbsp;</span>`;
            }
            html += '</div>';
        });

        // Add soil and atmospheric to their own charts if selected
        const soilVars = [];
        const atmosVars = [];
        Config.variableGroups.soil.variables.forEach(v => {
            if (this.selectedVariables.has(v.id) && hourly[v.id]) soilVars.push(v.id);
        });
        Config.variableGroups.atmospheric.variables.forEach(v => {
            if (this.selectedVariables.has(v.id) && hourly[v.id]) atmosVars.push(v.id);
        });

        if (soilVars.length > 0) {
            html += `<div class="chart-section chart-container-humidity">`;
            html += `<span class="y-label">Jord</span>`;
            html += `<div class="chart-canvas-wrapper"><canvas id="chart-soil-${panelId}"></canvas></div>`;
            html += `<span class="y-label-right">&nbsp;</span>`;
            html += '</div>';
        }

        if (atmosVars.length > 0) {
            html += `<div class="chart-section chart-container-humidity">`;
            html += `<span class="y-label">Atmos</span>`;
            html += `<div class="chart-canvas-wrapper"><canvas id="chart-atmos-${panelId}"></canvas></div>`;
            html += `<span class="y-label-right">&nbsp;</span>`;
            html += '</div>';
        }

        // Wind arrows
        if (this.selectedVariables.has('wind_direction_10m') && hourly.wind_direction_10m) {
            html += '<div class="wind-arrows-row">';
            displayIndices.forEach(i => html += `<div class="wind-arrow-cell">${Utils.getWindArrow(hourly.wind_direction_10m[i])}</div>`);
            html += '</div>';
        }

        // Hour labels
        html += '<div class="hour-labels">';
        displayIndices.forEach(i => html += `<div class="hour-label">${allTimes[i].getHours().toString().padStart(2, '0')}</div>`);
        html += '</div>';

        html += '</div>';
        container.innerHTML = html;

        // No longer need has-dual-axis class since all charts now have both axes

        // Create charts after layout settles
        const buildCharts = () => {
            Object.entries(chartGroups).forEach(([groupKey, group]) => {
                if (group.vars.length === 0) return;
                const options = groupKey === 'tempPrecip' ? { tempVars: group.tempVars, precipVars: group.precipVars } : {};
                this.createChart(panelId, groupKey, group.vars, hourly, allTimes, days, allVars, options);
            });
            if (soilVars.length > 0) {
                this.createChart(panelId, 'soil', soilVars, hourly, allTimes, days, allVars, {});
            }
            if (atmosVars.length > 0) {
                this.createChart(panelId, 'atmos', atmosVars, hourly, allTimes, days, allVars, {});
            }
        };
        // Use double-rAF to ensure DOM has fully laid out before measuring
        requestAnimationFrame(() => requestAnimationFrame(buildCharts));
    },

    createChart(panelId, groupKey, varIds, hourly, times, days, allVars, options = {}) {
        const ctx = document.getElementById(`chart-${groupKey}-${panelId}`);
        if (!ctx) return;

        const chartKey = `${groupKey}-${panelId}`;
        const existing = this.charts.get(chartKey);
        if (existing) existing.destroy();

        const isDualAxis = groupKey === 'tempPrecip' && options.tempVars?.length > 0 && options.precipVars?.length > 0;
        const precipVars = options.precipVars || [];

        // Helper to get temperature-based color
        const getTempColor = (val) => {
            if (val < -10) return '#1e40af';
            if (val < 0) return '#3b82f6';
            if (val < 10) return '#f59e0b';
            if (val < 20) return '#ef4444';
            return '#dc2626';
        };

        // X-axis range based on forecast mode
        const mode = Utils.storage.get('forecastMode', '48h');
        const now = new Date();
        now.setMinutes(0, 0, 0);
        let xMin, xMax;
        if (mode === '48h') {
            xMin = now > times[0] ? now : times[0];
            xMax = new Date(now.getTime() + 48 * 3600000);
        } else {
            xMin = new Date(now.getTime() + 48 * 3600000);
            xMax = new Date(now.getTime() + 192 * 3600000);
        }
        // Clamp to data bounds
        if (xMax > times[times.length - 1]) xMax = times[times.length - 1];

        const datasets = varIds.map(varId => {
            const v = allVars[varId];
            const isTemp = varId === 'temperature_2m';
            const isPrecipVar = precipVars.includes(varId);

            const dataset = {
                label: v.name,
                data: hourly[varId],
                borderColor: isTemp ? undefined : v.color,
                backgroundColor: v.type === 'bar' ? v.color + '80' : 'transparent',
                type: v.type === 'bar' ? 'bar' : 'line',
                tension: 0.3,
                pointRadius: 0,
                borderWidth: v.dashed ? 1.5 : 2,
                borderDash: v.dashed ? [4, 4] : undefined,
                barPercentage: 0.7,
                yAxisID: isDualAxis ? (isPrecipVar ? 'yRight' : 'yLeft') : 'yLeft'
            };

            if (isTemp) {
                dataset.segment = {
                    borderColor: (ctx) => getTempColor(ctx.p1.parsed.y)
                };
                dataset.borderColor = getTempColor(hourly[varId][0] || 0);
            }

            return dataset;
        });

        const annotations = {};
        days.forEach((d, i) => {
            if (i > 0) annotations[`day${i}`] = { type: 'line', xMin: times[d.start], xMax: times[d.start], borderColor: 'rgba(150,150,150,0.4)', borderWidth: 1 };
        });

        // ALL charts get both yLeft and yRight with fixed width for alignment
        const mobile = window.innerWidth <= 768;
        const fixedAxisWidth = mobile ? 20 : 30;
        const tickFont = { size: mobile ? 7 : 8 };
        const scales = {
            x: {
                type: 'time',
                time: { unit: 'hour', displayFormats: { hour: 'HH' } },
                ticks: { display: false },
                grid: { display: false },
                min: xMin,
                max: xMax
            },
            yLeft: {
                position: 'left',
                afterFit: (axis) => { axis.width = fixedAxisWidth; },
                ticks: { font: tickFont, color: '#888', stepSize: 2, precision: 0 },
                grid: { color: 'rgba(150,150,150,0.15)' }
            },
            yRight: {
                position: 'right',
                afterFit: (axis) => { axis.width = fixedAxisWidth; },
                ticks: isDualAxis ? { font: tickFont, color: '#60a5fa', stepSize: 2, precision: 0 } : { display: false },
                grid: { display: false },
                min: isDualAxis ? 0 : undefined
            }
        };

        const chart = new Chart(ctx, {
            type: 'line',
            data: { labels: times, datasets },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: { mode: 'index', intersect: false },
                plugins: { legend: { display: false }, annotation: { annotations } },
                scales
            }
        });

        this.charts.set(chartKey, chart);
    },

    removeCity(panelId) {
        const p = PanelManager.panels.get(panelId);
        if (p && p.config.city) {
            this.cities.delete(p.config.city.id);
            // Remove from all maps
            MapModule.maps.forEach(mapData => {
                const m = mapData.markers.get(p.config.city.id);
                if (m) { m.marker.remove(); mapData.markers.delete(p.config.city.id); }
            });
        }
        // Destroy charts
        this.charts.forEach((chart, key) => {
            if (key.endsWith(panelId)) { chart.destroy(); this.charts.delete(key); }
        });
        // Cleanup resize observer
        if (this.resizeObservers && this.resizeObservers.has(panelId)) {
            this.resizeObservers.get(panelId).disconnect();
            this.resizeObservers.delete(panelId);
        }
        this.weatherData.delete(panelId);
    },

    reRenderAll() {
        // Re-render from cached data (handles orientation change, axis width recalc)
        PanelManager.panels.forEach((p, id) => {
            if (p.type === 'city') {
                const data = this.weatherData.get(id);
                if (data) this.renderDetailedForecast(id, p.config.city, data);
            }
        });
    },

    refreshAll() {
        PanelManager.panels.forEach((p, id) => {
            if (p.type === 'city') this.fetchAndRender(id, p.config.city);
        });
    }
};

// ============================================
// CITY SEARCH
// ============================================
const CitySearch = {
    init() {
        const input = document.getElementById('city-search');
        const results = document.getElementById('search-results');

        const doSearch = Utils.debounce(async (q) => {
            if (q.length < 2) { results.classList.remove('active'); return; }
            const cities = await WeatherAPI.searchCities(q);
            this.renderResults(cities, results);
        }, 300);

        input.addEventListener('input', (e) => doSearch(e.target.value));
        input.addEventListener('focus', () => { if (input.value.length >= 2) results.classList.add('active'); });
        document.addEventListener('click', (e) => { if (!e.target.closest('.city-search-wrapper')) results.classList.remove('active'); });
    },

    renderResults(cities, container) {
        if (cities.length === 0) { container.innerHTML = '<div class="search-result-item">Ingen resultater</div>'; container.classList.add('active'); return; }
        container.innerHTML = cities.map(c => `<div class="search-result-item" data-lat="${c.latitude}" data-lon="${c.longitude}" data-name="${c.name}"><strong>${c.name}</strong><small>${c.admin1 || ''} ${c.country || ''}</small></div>`).join('');
        container.classList.add('active');
        container.querySelectorAll('.search-result-item').forEach(item => {
            item.addEventListener('click', () => {
                CityCards.createCityPanel({ name: item.dataset.name, lat: parseFloat(item.dataset.lat), lon: parseFloat(item.dataset.lon) });
                document.getElementById('city-search').value = '';
                container.classList.remove('active');
                PanelManager.scheduleArrange();
                PanelManager.saveLayout();
            });
        });
    }
};

// ============================================
// APPLICATION
// ============================================
const App = {
    init() {
        TimeTheme.init();
        CityCards.init();
        PanelManager.init();
        CitySearch.init();
        this.setupControls();
        setTimeout(() => MapModule.invalidateAllMaps(), 500);
        console.log('Morgendis initialized');
    },

    setupControls() {
        // Days toggle buttons
        const savedMode = Utils.storage.get('forecastMode', '48h');
        document.querySelectorAll('.days-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.mode === savedMode);
            btn.addEventListener('click', () => {
                document.querySelectorAll('.days-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                Utils.storage.set('forecastMode', btn.dataset.mode);
                CityCards.refreshAll();
            });
        });

        document.getElementById('add-map-btn').addEventListener('click', () => {
            MapModule.createMapPanel();
            PanelManager.scheduleArrange();
        });
        document.getElementById('reset-btn').addEventListener('click', () => {
            if (confirm('Nulstil alt?')) { localStorage.clear(); location.reload(); }
        });
    }
};

document.addEventListener('DOMContentLoaded', () => App.init());
    </script>
</body>
</html>
